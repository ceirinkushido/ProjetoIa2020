;;; Tabuleiros
(defun teste ()
"Fun√ß√£o que representa um tabuleiro de teste"
  '(
		(
			((branca redonda alta oca) 0 0 0) 
			(0 (preta redonda alta oca) 0 0) 
			(0 0 (branca redonda baixa oca) 0) 
			(0 0 0 0)
		)
		(
                        (preta redonda baixa oca)
			(branca quadrada alta oca)
			(preta quadrada alta oca)
			(branca quadrada baixa oca)
			(preta quadrada baixa oca)
			(branca redonda alta cheia)
			(preta redonda alta cheia)
			(branca redonda baixa cheia)
			(preta redonda baixa cheia)
			(branca quadrada alta cheia)
			(preta quadrada alta cheia)
			(branca quadrada baixa cheia)
			(preta quadrada baixa cheia)
		)
	)
)

;;; Fun√ß√£o que recebe uma lista que cont√©m um tabuleiro com reservas de pe√ßa e devolve o tabuleiro
(defun tabuleiro (table)
  (car table))

;;; Fun√ß√£o que recebe uma lista que cont√©m um tabuleiro com reservas de pe√ßa e devolve a reserva de pe√ßas.
(defun reserva (table)
  (cadr table))

;;; Fun√ß√£o que recebe um √≠ndice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro.
(defun linha (index table)
  (nth index table))

;;; Fun√ß√£o que recebe um √≠ndice e o tabuleiro e retorna uma lista que representa essa coluna do tabuleiro
(defun coluna (index table)
  (mapcar #'(lambda (subtable) (nth index subtable)) table))

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna) e o tabuleiro e retorna o valor presente nessa c√©lula do tabuleiro.
(defun celula (x y table)
  (nth y (nth x table)))

;;; Fun√ß√£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-1 (tabuleiro (teste))) -> ((branca redonda alta oca) (preta redonda alta oca) (branca redonda baixa oca) 0)
(defun diagonal-1(table)
  (if (null table) '()
  (cons (caar table) (diagonal-1 (mapcar #'cdr (cdr table))))))

;;; Fun√ß√£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-2 (tabuleiro (teste))) -> (0 0 0 0)
(defun diagonal-2(table)
  (diagonal-1 (reverse table)))

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna) e o tabuleiro e devolve T se a casa estiver vazia e NIL caso contr√°rio.
;;; O valor de uma casa vazia no Problema do Quatro √© o valor 0.
;;; (casa-vaziap 0 1 (tabuleiro (teste))) -> T
;;; (casa-vaziap 0 0 (tabuleiro (teste))) -> NIL
(defun casa-vaziap (line col table)
  (cond 
   ((atom (celula line col table)) T )
   (NIL)))

;;; Fun√ß√£o que recebe uma pe√ßa e uma lista com as pe√ßas de reserva e devolve uma nova lista sem essa pe√ßa de reserva
(defun remover-peca (piece reserved-pieces)
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces))
    (remover-peca piece (cdr reserved-pieces)))
   (T (cons (car reserved-pieces) (remover-peca piece (cdr reserved-pieces))))))

;;; Fun√ß√£o que recebe um √≠ndice, uma pe√ßa e uma lista que representar√° uma linha do tabuleiro
;;;  e substitui pelo valor pretendido nessa posi√ß√£o.
(defun substituir-posicao (index piece line)
  (setf (nth index line) piece)
  line)

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna), uma pe√ßa e o tabuleiro.
;;; A fun√ß√£o dever√° retornar o tabuleiro com a c√©lula substitu√≠da pelo valor pretendido. 
(defun substituir (line col piece table)
  (substituir-posicao col piece (nth line table))
  table)


;;Recebe uma lista de 4 peÁas e verifica se existe 4 propriedades iguais nas peÁas.
(defun verifica-propriedades (lista-pecas)
 (cond 
   ((AND(equal (car (first lista-pecas)) (car (second lista-pecas))) (equal (car (second lista-pecas)) (car (third lista-pecas))) 
        (equal (car (third lista-pecas)) (car (fourth lista-pecas)))) T)
   ((AND(equal (cadr (first lista-pecas)) (cadr (second lista-pecas))) (equal (cadr (second lista-pecas)) (cadr (third lista-pecas))) 
        (equal (cadr (third lista-pecas)) (cadr (fourth lista-pecas)))) T)
   ((AND(equal (caddr (first lista-pecas)) (caddr (second lista-pecas))) (equal (caddr (second lista-pecas)) (caddr (third lista-pecas))) 
        (equal (caddr (third lista-pecas)) (caddr (fourth lista-pecas)))) T)
     ((AND(equal (cadddr (first lista-pecas)) (cadddr (second lista-pecas))) (equal (cadddr (second lista-pecas)) (cadddr (third lista-pecas))) 
        (equal (cadddr (third lista-pecas)) (cadddr (fourth lista-pecas)))) T)
   (T NIL))
   
 
)




;;; =================================================OPERADORES=====================================

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna), uma lista que representar√° uma pe√ßa e
;;;  o tabuleiro com reservas de peca e movimenta a pe√ßa para a c√©lula correspondente, removendo-a da reserva de pe√ßas.
(defun operador (line col piece table)
  (cond
   ( (casa-vaziap line col (tabuleiro table))
     (setf table (list 
                  (substituir line col piece (tabuleiro table)) 
                  (remover-peca piece (reserva table))
                  ))table)
     (
   NIL))
)


;; No(estado do no(tabuleiro , lista de reserva) movimento e a profundidade)

(defun generate-descendants(state open)
   (mapcar #'(lambda (piece) (run-operator state piece open 0 0 )) (reserva state))
)



(defun run-operator (state piece open &optional (col 0) (line 0) )
  (cond 
   ((and (< col 4) (operador line col piece state) )
    (append open (list (list line col))  (run-operator state piece open (+ col 1) line )))
   ((< col 4) (run-operator state piece open (+ col 1) line ))
   ((< line 3) (run-operator state piece open 0 (+ line 1)))
   )
)
 
;;; BFS
;;; 
 
