;;; Tabuleiros
(defun teste ()
"Fun√ß√£o que representa um tabuleiro de teste"
  '(
		(
			(0 0 0 (branca redonda alta oca) ) 
			(0 0 0 (preta redonda alta oca) )  
			(0 0 0 (branca redonda baixa oca) ) 
			(0 0 0 0) 
		)
		(
                        (preta redonda baixa oca)
			(branca quadrada alta oca)
			(preta quadrada alta oca)
			(branca quadrada baixa oca)
			(preta quadrada baixa oca)
			(branca redonda alta cheia)
			(preta redonda alta cheia)
			(branca redonda baixa cheia)
			(preta redonda baixa cheia)
			(branca quadrada alta cheia)
			(preta quadrada alta cheia)
			(branca quadrada baixa cheia)
			(preta quadrada baixa cheia)
		)
	)
)

;;; Fun√ß√£o que recebe uma lista que cont√©m um tabuleiro com reservas de pe√ßa e devolve o tabuleiro
(defun tabuleiro (table)
  (car table))

;;; Fun√ß√£o que recebe uma lista que cont√©m um tabuleiro com reservas de pe√ßa e devolve a reserva de pe√ßas.
(defun reserva (table)
  (cadr table))

;;; Fun√ß√£o que recebe um √≠ndice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro.
(defun linha (index table)
  (cond
   ((= index 0) (car table))
   (t (linha (1- index) (cdr table)))))

;;; Fun√ß√£o que recebe um √≠ndice e o tabuleiro e retorna uma lista que representa essa coluna do tabuleiro
(defun coluna (index table)
  (cond
   ((null table) nil)
   (t (cons (linha index (car table)) (coluna index (cdr table)))) ))

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna) e o tabuleiro e retorna o valor presente nessa c√©lula do tabuleiro.
(defun celula (x y table)
  (nth y (nth x table)))

;;; Fun√ß√£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-1 (tabuleiro (teste))) -> ((branca redonda alta oca) (preta redonda alta oca) (branca redonda baixa oca) 0)
(defun diagonal-1(table)
  (if (null table) '()
  (cons (caar table) (diagonal-1 (mapcar #'cdr (cdr table))))))

;;; Fun√ß√£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-2 (tabuleiro (teste))) -> (0 0 0 0)
(defun diagonal-2(table)
  (diagonal-1 (reverse table)))

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna) e o tabuleiro e devolve T se a casa estiver vazia e NIL caso contr√°rio.
;;; O valor de uma casa vazia no Problema do Quatro √© o valor 0.
;;; (casa-vaziap 0 1 (tabuleiro (teste))) -> T
;;; (casa-vaziap 0 0 (tabuleiro (teste))) -> NIL
(defun casa-vaziap (line col table)
  (cond 
   ((atom (celula line col table)) T )
   (NIL)))

;;; Fun√ß√£o que recebe uma pe√ßa e uma lista com as pe√ßas de reserva e devolve uma nova lista sem essa pe√ßa de reserva
(defun remover-peca (piece reserved-pieces)
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces))
    (remover-peca piece (cdr reserved-pieces)))
   (T (cons (car reserved-pieces) (remover-peca piece (cdr reserved-pieces))))))

;;; Fun√ß√£o que recebe um √≠ndice, uma pe√ßa e uma lista que representar√° uma linha do tabuleiro
;;;  e substitui pelo valor pretendido nessa posi√ß√£o.
(defun substituir-posicao (index piece line)
  (cond
   ((null line) nil)
   ((= index -1) (append (cons (car line) nil) (substituir-posicao index piece (cdr line))))
   ((= index 0) (append (cons piece nil) (substituir-posicao (1- index) piece (cdr line))))
   (t (append (cons (car line) nil) (substituir-posicao (1- index) piece (cdr line)))) ))

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna), uma pe√ßa e o tabuleiro.
;;; A fun√ß√£o dever√° retornar o tabuleiro com a c√©lula substitu√≠da pelo valor pretendido. 
(defun substituir (line col piece table)
  (cond ((null table) nil)
        ((= line 0) (cons (substituir-posicao col piece (car table)) 
                          (substituir (1- line) col piece (cdr table))))
        (t (cons (car table) (substituir (1- line) col piece (cdr table))))))

;;Recebe um tabuleiro  e verifica se existe 4 propriedades iguais nas peÁas.
(defun verifica-propriedades (lista-pecas &optional (index 0))

    (cond 
     ((and (< index 3) (comparar-linha-coluna(linha index lista-pecas)) (comparar-linha-coluna(coluna index lista-pecas)))
     (verifica-propriedades lista-pecas (+ 1 index))) 
     ((or (not(comparar-linha-coluna (linha index lista-pecas) )) (not(comparar-linha-coluna (coluna index lista-pecas)))
          (not(comparar-linha-coluna (diagonal-1 lista-pecas)))  (not(comparar-linha-coluna (diagonal-1 lista-pecas))))  
       T) 
     (nil))
  
        
)


;; Todas as peÁas diferentes de 0 e qualquer combinaÁ„o das 4 propriedadades iguais 
(defun comparar-linha-coluna (linha)

  (cond ((and (not(equal 0 (car linha))) (not(equal 0 (cadr linha))) (not(equal 0 (caddr linha))) (not(equal 0 (cadddr linha))) 
        (or (and (equal (car (first linha)) (car (second linha))) (equal (car (second linha)) (car (third linha))) 
             (equal (car (third linha)) (car (fourth linha))) )  
            (AND(equal (cadr (first linha)) (cadr (second linha))) (equal (cadr (second linha)) (cadr (third linha))) 
             (equal (cadr (third linha)) (cadr (fourth linha))) ) 
            (AND(equal (caddr (first linha)) (caddr (second linha))) (equal (caddr (second linha)) (caddr (third linha))) 
             (equal (caddr (third linha)) (caddr (fourth linha))) ) 
            (AND(equal (cadddr (first linha)) (cadddr (second linha))) (equal (cadddr (second linha)) (cadddr (third linha)))
             (equal (cadddr (third linha)) (cadddr (fourth linha))) )
         ) ) nil)
             (t) 
    )
        

)





;;; =================================================OPERADORES=====================================

;;; Fun√ß√£o que recebe dois √≠ndices (linha e coluna), uma lista que representar√° uma pe√ßa e
;;;  o tabuleiro com reservas de peca e movimenta a pe√ßa para a c√©lula correspondente, removendo-a da reserva de pe√ßas.
(defun operador (line col piece table)
  (cond
   ( (casa-vaziap line col (tabuleiro table))
     (list (substituir line col piece (tabuleiro table)) (remover-peca piece (reserva table)) ))
     (t nil)))

;; No(estado do no(tabuleiro , lista de reserva) movimento e a profundidade)
(defun generate-descendants-bfs(state &optional (depth 0))
    (mapcar #'(lambda (piece) (run-operator state piece 0 0 depth )) (reserva state)))

(defun run-operator (table piece &optional (line 0) (col 0) (depth 0) )
  (cond 
   ((and (< col 3) (operador line col piece table) )
    (append (list (list depth (operador line col piece table) (list piece line col)))
            (run-operator table piece line (+ col 1) depth)))
   ((< col 3) (run-operator table piece line (+ col 1) depth))
   ((< line 3) (run-operator table piece (+ line 1) depth))
   (t nil) ))


;;; Tirar o estado dos abertos e por nos fechados depois gerar os sucessores do estado atual e colocar nos abertos
;;; BFS
(defun bfs (&optional (open '()) (closed '()) (max-depth 2) (initial-node nil))
  (cond ((null open) nil)
        ((null initial-node) (bfs (abertos-bfs open 0) '() max-depth open))
         (t (let ((state (car open)))
           (cond 
            ((or (verifica-propriedades (tabuleiro(cadr state)) ) (>= (car state) max-depth)) state)
            (t (bfs (append (cdr open) (abertos-bfs (cadr state) (+ 1 (car state)) ))
                    (list state closed) max-depth initial-node)))) )))

(defun abertos-bfs (state &optional (depth 0))
  (apply #'append (generate-descendants-bfs state depth))
)