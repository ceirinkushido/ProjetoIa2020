;;; Tabuleiros
(defun teste ()
"FunÃ§Ã£o que representa um tabuleiro de teste"
  '(
		(
			((branca redonda alta oca) 0 0 0) 
			(0 (preta redonda alta oca) 0 0) 
			(0 0 (branca redonda baixa oca) 0) 
			(0 0 0 0)
		)
		(
                        (preta redonda baixa oca)
			(branca quadrada alta oca)
			(preta quadrada alta oca)
			(branca quadrada baixa oca)
			(preta quadrada baixa oca)
			(branca redonda alta cheia)
			(preta redonda alta cheia)
			(branca redonda baixa cheia)
			(preta redonda baixa cheia)
			(branca quadrada alta cheia)
			(preta quadrada alta cheia)
			(branca quadrada baixa cheia)
			(preta quadrada baixa cheia)
		)
	)
)

;;; FunÃ§Ã£o que recebe uma lista que contÃ©m um tabuleiro com reservas de peÃ§a e devolve o tabuleiro
(defun tabuleiro (table)
  (car table))

;;; FunÃ§Ã£o que recebe uma lista que contÃ©m um tabuleiro com reservas de peÃ§a e devolve a reserva de peÃ§as.
(defun reserva (table)
  (cadr table))

;;; FunÃ§Ã£o que recebe um Ã­ndice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro.
(defun linha (index table)
  (nth index table))

;;; FunÃ§Ã£o que recebe um Ã­ndice e o tabuleiro e retorna uma lista que representa essa coluna do tabuleiro
(defun coluna (index table)
  (mapcar #'(lambda (subtable) (nth index subtable)) table))

;;; FunÃ§Ã£o que recebe dois Ã­ndices (linha e coluna) e o tabuleiro e retorna o valor presente nessa cÃ©lula do tabuleiro.
(defun celula (x y table)
  (nth y (nth x table)))

;;; FunÃ§Ã£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-1 (tabuleiro (teste))) -> ((branca redonda alta oca) (preta redonda alta oca) (branca redonda baixa oca) 0)
(defun diagonal-1(table)
  (if (null table) '()
  (cons (caar table) (diagonal-1 (mapcar #'cdr (cdr table))))))

;;; FunÃ§Ã£o que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-2 (tabuleiro (teste))) -> (0 0 0 0)
(defun diagonal-2(table)
  (diagonal-1 (reverse table)))

;;; FunÃ§Ã£o que recebe dois Ã­ndices (linha e coluna) e o tabuleiro e devolve T se a casa estiver vazia e NIL caso contrÃ¡rio.
;;; O valor de uma casa vazia no Problema do Quatro Ã© o valor 0.
;;; (casa-vaziap 0 1 (tabuleiro (teste))) -> T
;;; (casa-vaziap 0 0 (tabuleiro (teste))) -> NIL
(defun casa-vaziap (line col table)
  (cond 
   ((atom (celula line col table)) T )
   (NIL)))

;;; FunÃ§Ã£o que recebe uma peÃ§a e uma lista com as peÃ§as de reserva e devolve uma nova lista sem essa peÃ§a de reserva
(defun remover-peca (piece reserved-pieces)
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces))
    (remover-peca piece (cdr reserved-pieces)))
   (T (cons (car reserved-pieces) (remover-peca piece (cdr reserved-pieces))))))

;;; FunÃ§Ã£o que recebe um Ã­ndice, uma peÃ§a e uma lista que representarÃ¡ uma linha do tabuleiro
;;;  e substitui pelo valor pretendido nessa posiÃ§Ã£o.
(defun substituir-posicao (index piece line)
  (cond
   ((null line) nil)
   ((= index -1) (append (cons (car line) nil) (substituir-posicao index piece (cdr line))))
   ((= index 0) (append (cons piece nil) (substituir-posicao (1- index) piece (cdr line))))
   (t (append (cons (car line) nil) (substituir-posicao (- 1 index) piece (cdr line)))) ))

;;; FunÃ§Ã£o que recebe dois Ã­ndices (linha e coluna), uma peÃ§a e o tabuleiro.
;;; A funÃ§Ã£o deverÃ¡ retornar o tabuleiro com a cÃ©lula substituÃ­da pelo valor pretendido. 
(defun substituir (line col piece table)
  (substituir-posicao col piece (nth line table))
  table)


;;Recebe uma lista de 4 peças e verifica se existe 4 propriedades iguais nas peças.
(defun verifica-propriedades (lista-pecas)
 (cond 
   ((AND(equal (car (first lista-pecas)) (car (second lista-pecas))) (equal (car (second lista-pecas)) (car (third lista-pecas))) 
        (equal (car (third lista-pecas)) (car (fourth lista-pecas)))) T)
   ((AND(equal (cadr (first lista-pecas)) (cadr (second lista-pecas))) (equal (cadr (second lista-pecas)) (cadr (third lista-pecas))) 
        (equal (cadr (third lista-pecas)) (cadr (fourth lista-pecas)))) T)
   ((AND(equal (caddr (first lista-pecas)) (caddr (second lista-pecas))) (equal (caddr (second lista-pecas)) (caddr (third lista-pecas))) 
        (equal (caddr (third lista-pecas)) (caddr (fourth lista-pecas)))) T)
     ((AND(equal (cadddr (first lista-pecas)) (cadddr (second lista-pecas))) (equal (cadddr (second lista-pecas)) (cadddr (third lista-pecas))) 
        (equal (cadddr (third lista-pecas)) (cadddr (fourth lista-pecas)))) T)
   (T NIL))
   
 
)




;;; =================================================OPERADORES=====================================

;;; FunÃ§Ã£o que recebe dois Ã­ndices (linha e coluna), uma lista que representarÃ¡ uma peÃ§a e
;;;  o tabuleiro com reservas de peca e movimenta a peÃ§a para a cÃ©lula correspondente, removendo-a da reserva de peÃ§as.
(defun operador (line col piece table)
  (cond
   ( (casa-vaziap line col (tabuleiro table))
     (list 
      (substituir line col piece (tabuleiro table)) 
      (remover-peca piece (reserva table))))
     (NIL))
)


;; No(estado do no(tabuleiro , lista de reserva) movimento e a profundidade)

(defun generate-descendants(state open)
   (mapcar #'(lambda (piece) (list  (run-operator state piece open 0 0 )) (reserva state))
)



(defun run-operator (state piece open &optional (col 0) (line 0) )
  (cond 
   ((and (< col 4) (operador line col piece state) )
    (append open (list (list line col))  (run-operator state piece open (+ col 1) line )))
   ((< col 4) (run-operator state piece open (+ col 1) line ))
   ((< line 3) (run-operator state piece open 0 (+ line 1)))
   (t open)
   )
)
 
;;; BFS
;;; 
 
