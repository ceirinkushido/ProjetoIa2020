;;; Tabuleiros iniciais
(defun initial-board-short ()
  "Funcao que representa um tabuleiro de teste"
  '(
    (
     (0 0 0 0) (0 0 0 0)(0 0 0 0) (0 0 0 0)
     )
    (
     (b r a o)
     (p r a o)
     (b r b o)
     (b r a c)
     (p r b o)
     (b q a o)
     (p q a o)
     (b q b o)
     (p q b o)
     (b r a c)
     (p r a c)
     (b r b c)
     (p r b c)
     (b q a c)
     (p q a c)
     (b q b c)
     (p q b c)
     )))

(defun initial-board ()
  "Funcao que representa um tabuleiro de teste"
  '(
    (
     (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0)
     )
    (
     (branca redonda alta oca)
     (preta redonda alta oca)
     (branca redonda baixa oca)
     (preta redonda baixa oca)
     (branca quadrada alta oca)
     (preta quadrada alta oca)
     (branca quadrada baixa oca)
     (preta quadrada baixa oca)
     (branca redonda alta cheia)
     (preta redonda alta cheia)
     (branca redonda baixa cheia)
     (preta redonda baixa cheia)
     (branca quadrada alta cheia)
     (preta quadrada alta cheia)
     (branca quadrada baixa cheia)
     (preta quadrada baixa cheia)
     )))

;; ==========BROARD POSITION FUNCTIONS==========

;;; Funcao que recebe uma lista que contem um tabuleiro com reservas de pecas e devolve o tabuleiro
(defun tabuleiro (table)
  (car table))

;;; Funcao que recebe uma lista que contem um tabuleiro com reservas de pecas e devolve a reserva de pecas.
(defun reserva (table)
  (cadr table))

;;; Funcao que recebe um indice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro.
(defun linha (index table)
  (cond
   ((= index 0) (car table))
   (t (linha (1- index) (cdr table)))))

;;; Funcao que recebe um indice e o tabuleiro e retorna uma lista que representa essa coluna do tabuleiro
(defun coluna (index table)
  (cond
   ((null table) nil)
   (t (cons (linha index (car table)) (coluna index (cdr table)))) ))

;;; Funcaoo que recebe dois indices (linha e coluna) e o tabuleiro e retorna o valor presente nessa celula do tabuleiro
(defun celula (x y table)
  (nth y (nth x table)))

;;; Funcao que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-1 (tabuleiro (teste))) -> ((branca redonda alta oca) (preta redonda alta oca) (branca redonda baixa oca) 0)
(defun diagonal-1(table)
  (if (null table) '()
  (cons (caar table) (diagonal-1 (mapcar #'cdr (cdr table))))))

;;; Funcao que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro.
;;; (diagonal-2 (tabuleiro (teste))) -> (0 0 0 0)
(defun diagonal-2(table)
  (diagonal-1 (reverse table)))


;; ==========BOARD OPERATION FUNCTIONS==========

;;; Funcao que recebe dois indices (linha e coluna) e o tabuleiro e devolve T se a casa estiver vazia e NIL caso contrario.
;;; O valor de uma casa vazia no Problema do Quatro tem o valor 0.
;;; (casa-vaziap 0 1 (tabuleiro (teste))) -> T
;;; (casa-vaziap 0 0 (tabuleiro (teste))) -> NIL
(defun casa-vaziap (line col table)
  (cond 
   ((atom (celula line col table)) T )
   (NIL)))

;;; Funcao que recebe uma peca e uma lista com as pecas de reserva e devolve uma nova lista sem essa peca
(defun remover-peca (piece reserved-pieces)
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces))
    (remover-peca piece (cdr reserved-pieces)))
   (T (cons (car reserved-pieces) (remover-peca piece (cdr reserved-pieces))))))

;;; Funcao que recebe um indice, uma peca e uma lista que representara uma linha do tabuleiro
;;;  e substitui pelo valor pretendido nessa posicao.
(defun substituir-posicao (index piece line)
  (cond
   ((null line) nil)
   ((= index -1) (append (cons (car line) nil) (substituir-posicao index piece (cdr line))))
   ((= index 0) (append (cons piece nil) (substituir-posicao (1- index) piece (cdr line))))
   (t (append (cons (car line) nil) (substituir-posicao (1- index) piece (cdr line)))) ))

;;; Funcao que recebe dois indices (linha e coluna), uma peca e o tabuleiro.
;;; A funcao devera retornar o tabuleiro com a celula substituida pelo valor pretendido. 
(defun substituir (line col piece table)
  (cond ((null table) nil)
        ((= line 0) (cons (substituir-posicao col piece (car table)) 
                          (substituir (1- line) col piece (cdr table))))
        (t (cons (car table) (substituir (1- line) col piece (cdr table))))))

;;Funcao que recebe um tabuleiro  e verifica se existe 4 propriedades iguais nas peças.
(defun verifica-propriedades (lista-pecas &optional (index 0))
  (cond 
   ((and (< index 3) (comparar-linha-coluna(linha index lista-pecas)) (comparar-linha-coluna(coluna index lista-pecas)))
    (verifica-propriedades lista-pecas (+ 1 index))) 
   ((or (not(comparar-linha-coluna (linha index lista-pecas) )) (not(comparar-linha-coluna (coluna index lista-pecas)))
        (not(comparar-linha-coluna (diagonal-1 lista-pecas)))  (not(comparar-linha-coluna (diagonal-2 lista-pecas))))  
    T)
   (nil)))

;;Funcao que testa todas as pecas diferentes de 0 e qualquer combinação das 4 propriedadades iguais 
(defun comparar-linha-coluna (linha)
  (cond (
         (and
          (not(equal 0 (car linha))) (not(equal 0 (cadr linha))) (not(equal 0 (caddr linha))) (not(equal 0 (cadddr linha))) 
          (or (and
               (equal (car (first linha)) (car (second linha))) (equal (car (second linha)) (car (third linha))) 
               (equal (car (third linha)) (car (fourth linha))) )  
              (AND
               (equal (cadr (first linha)) (cadr (second linha))) (equal (cadr (second linha)) (cadr (third linha))) 
               (equal (cadr (third linha)) (cadr (fourth linha))) ) 
              (AND
               (equal (caddr (first linha)) (caddr (second linha))) (equal (caddr (second linha)) (caddr (third linha))) 
               (equal (caddr (third linha)) (caddr (fourth linha))) ) 
              (AND
               (equal (cadddr (first linha)) (cadddr (second linha)))
               (equal (cadddr (second linha)) (cadddr (third linha)))
               (equal (cadddr (third linha)) (cadddr (fourth linha))) )) ) nil)
        (t)))


;;;Funcao que efetua uma jogada (de jogador ou cpu)
(defun jogar (estado tempo)
  (cond
   ( (nil tempo) (format t "Player move"))
   ( (<= tempo 0)
     ;; Verificar tempo restante apos algoritmo?
     (format t "Game Over.~% By: Time Out"))
   (t (format t "Game continues ~A" estado))) )

(defun gameplay-loop (game-mode current-player time-limit &optional (current-state (initial-board-short)) )
  (cond
   ( (= game-mode 1)
     (cond
      ( (AND (= current-player 1) (NOT (verifica-propriedades (tabuleiro current-state))) )
        (gameplay-loop game-mode 2 time-limit (jogar current-state nil)))
      ( (AND (= current-player 2) (NOT (verifica-propriedades (tabuleiro current-state))) )
        ;; Alterar Tempo Limite a cada Jogada?
        (gameplay-loop game-mode 1 time-limit (jogar current-state time-limit)))
      (t (format t "Game Over!~% Player ~A Wins." current-player))))
   (t
    (cond
     ( (AND (= current-player 1) (NOT (verifica-propriedades (tabuleiro current-state))) )
       (gameplay-loop game-mode 2 time-limit (jogar current-state nil)))
     ( (AND (= current-player 2) (NOT (verifica-propriedades (tabuleiro current-state))) )
       ;; Alterar Tempo Limite a cada Jogada?
       (gameplay-loop game-mode 1 time-limit (jogar current-state time-limit)))
     (t (format t "Game Over!~% Player ~A Wins." current-player)))
    )))
          

;;(format t "Game Over.~% By: Board State"))(jogar estado tempo) )


      
      


;;; =================================================OPERADORES===========================================
;;Funcao vai receber uma linha coluna a peca e tabuleiro e operar usando uma lista de operadores no tabuleiro
(defun operador (line col piece table)
  (cond
   ( (casa-vaziap line col (tabuleiro table))
     (list (substituir line col piece (tabuleiro table)) (remover-peca piece (reserva table)) ))
     (t nil)))

;;Funcao que opera sobre o tabuleiro e tenta jogar a peca no tabuleiro 
(defun run-operator (state piece &optional (line 0) (col 0) (depth 0) )
  (cond 
   ((and (< col 4) (operador line col piece state) )
    (append
     (list (cria-no (operador line col piece state) (+ 1 depth) state) )
          (run-operator state piece line (+ col 1) depth)))
   ((< col 4) (run-operator state piece line (+ col 1) depth))
   ((and (< line 3)) (run-operator state piece (+ line 1) 0 depth))
   (t nil) ))
