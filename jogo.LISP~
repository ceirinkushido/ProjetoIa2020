;;; Tabuleiros iniciais
(defun initial-board-short ()
  "Funcao que representa um tabuleiro de teste com as iniciais de cada palavra"
  '(
    (
     ((b r a o) 0 0 0) (0 0 0 0)(0 0 0 0) (0 0 0 0)
     )
    (
     
     (p r a o)
     (b r b o)
     (b r a c)
     (p r b o)
     (b q a o)
     (p q a o)
     (b q b o)
     (p q b o)
     (b r a c)
     (p r a c)
     (b r b c)
     (p r b c)
     (b q a c)
     (p q a c)
     (b q b c)
     (p q b c)
     )))

(defun test-board ()
  '((
     ((branca quadrada alta oca) (preta redonda baixa oca) (preta quadrada alta oca) (branca quadrada alta cheia))
     ((branca redonda alta oca) 0 (branca redonda alta cheia) 0)
     ((preta quadrada baixa cheia) (preta redonda alta cheia) (branca quadrada baixa oca) 0)
     ((preta quadrada baixa oca) 0 (branca quadrada baixa cheia) 0)
     )
    ((branca redonda baixa oca)
     (preta redonda baixa cheia)
     (preta redonda alta oca)
     (preta quadrada alta cheia)
     (branca redonda baixa cheia)
     )))

(defun initial-board ()
  "Funcao que representa um tabuleiro de teste"
  '(
    (
     (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0)
     )
    (
     (branca redonda alta oca)
     (preta redonda alta oca)
     (branca redonda baixa oca)
     (preta redonda baixa oca)
     (branca quadrada alta oca)
     (preta quadrada alta oca)
     (branca quadrada baixa oca)
     (preta quadrada baixa oca)
     (branca redonda alta cheia)
     (preta redonda alta cheia)
     (branca redonda baixa cheia)
     (preta redonda baixa cheia)
     (branca quadrada alta cheia)
     (preta quadrada alta cheia)
     (branca quadrada baixa cheia)
     (preta quadrada baixa cheia)
     )))

;; ==========BROARD POSITION FUNCTIONS==========

(defun tabuleiro (table)
  "Funcao que recebe uma lista que contem um tabuleiro com reservas de pecas e devolve o tabuleiro"
  (car(cadr table)))

(defun reserva (table)
  "Funcao que recebe uma lista que contem um tabuleiro com reservas de pecas e devolve a reserva de pecas."
  (cadr(cadr table)))

(defun linha (index table)
  "Funcao que recebe um indice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro."
  (cond
   ((= index 0) (car table))
   (t (linha (1- index) (cdr table)))))

(defun coluna (index table)
  "Funcao que recebe um indice e o tabuleiro e retorna uma lista que representa essa coluna do tabuleiro"
  (cond
   ((null table) nil)
   (t (cons (linha index (car table)) (coluna index (cdr table)))) ))

(defun celula (x y table)
  "Funcaoo que recebe dois indices (linha e coluna) e o tabuleiro e retorna o valor presente nessa celula do tabuleiro"
  (nth y (nth x table)))

;;; (diagonal-1 (tabuleiro (teste))) -> ((branca redonda alta oca) (preta redonda alta oca) (branca redonda baixa oca) 0)
(defun diagonal-1(table)
  "Funcao que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro."
  (if (null table) '()
  (cons (caar table) (diagonal-1 (mapcar #'cdr (cdr table))))))

;;; (diagonal-2 (tabuleiro (teste))) -> (0 0 0 0)
(defun diagonal-2(table)
  "Funcao que recebe um tabuleiro e retorna uma lista que representa uma diagonal desse tabuleiro."
  (diagonal-1 (reverse table)))


;; ==========BOARD OPERATION FUNCTIONS==========

;;; (casa-vaziap 0 1 (tabuleiro (teste))) -> T
;;; (casa-vaziap 0 0 (tabuleiro (teste))) -> NIL
(defun casa-vaziap (line col table)
  "Funcao que recebe dois indices (linha e coluna) e o tabuleiro e devolve T se a casa estiver vazia e NIL caso contrario."
  (cond 
   ((atom (celula line col table)) T )
   (NIL)))

(defun remover-peca (piece reserved-pieces)
  "Funcao que recebe uma peca e uma lista com as pecas de reserva e devolve uma nova lista sem essa peca"
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces))
    (remover-peca piece (cdr reserved-pieces)))
   (T (cons (car reserved-pieces) (remover-peca piece (cdr reserved-pieces))))))

(defun substituir-posicao (index piece line)
  "Funcao que recebe um indice, uma peca e uma linha do tabuleiro. Substitui a peca na posicao indicada."
  (cond
   ((null line) nil)
   ((= index -1) (append (cons (car line) nil) (substituir-posicao index piece (cdr line))))
   ((= index 0) (append (cons piece nil) (substituir-posicao (1- index) piece (cdr line))))
   (t (append (cons (car line) nil) (substituir-posicao (1- index) piece (cdr line)))) ))

(defun substituir (line col piece table)
  "Funcao que retorna o tabuleiro com a celula substituida pelo valor pretendido. "
  (cond ((null table) nil)
        ((= line 0) (cons (substituir-posicao col piece (car table)) 
                          (substituir (1- line) col piece (cdr table))))
        (t (cons (car table) (substituir (1- line) col piece (cdr table))))))


(defun verifica-propriedades (lista-pecas &optional (index 0))
  "Funcao que recebe um tabuleiro e verifica se existem 4 propriedades iguais nas pecas."
  (cond 
   ((and (< index 3) (comparar-linha-coluna(linha index lista-pecas)) (comparar-linha-coluna(coluna index lista-pecas)))
    (verifica-propriedades lista-pecas (+ 1 index))) 
   ((or (not(comparar-linha-coluna (linha index lista-pecas) )) (not(comparar-linha-coluna (coluna index lista-pecas)))
        (not(comparar-linha-coluna (diagonal-1 lista-pecas)))  (not(comparar-linha-coluna (diagonal-2 lista-pecas))))  
    T)
   (nil)))

(defun comparar-linha-coluna (linha)
  "Funcao que testa todas as pecas diferentes de 0 e qualquer combinacao das 4 propriedadades iguais "
  (cond (
         (and
          (not(equal 0 (car linha))) (not(equal 0 (cadr linha))) (not(equal 0 (caddr linha))) (not(equal 0 (cadddr linha))) 
          (or (and
               (equal (car (first linha)) (car (second linha))) (equal (car (second linha)) (car (third linha))) 
               (equal (car (third linha)) (car (fourth linha))) )  
              (AND
               (equal (cadr (first linha)) (cadr (second linha))) (equal (cadr (second linha)) (cadr (third linha))) 
               (equal (cadr (third linha)) (cadr (fourth linha))) ) 
              (AND
               (equal (caddr (first linha)) (caddr (second linha))) (equal (caddr (second linha)) (caddr (third linha))) 
               (equal (caddr (third linha)) (caddr (fourth linha))) ) 
              (AND
               (equal (cadddr (first linha)) (cadddr (second linha)))
               (equal (cadddr (second linha)) (cadddr (third linha)))
               (equal (cadddr (third linha)) (cadddr (fourth linha))) )) ) nil)
        (t)))

;;; =================================================OPERADORES===========================================
(defun operador (line col piece table)
  "Funcao recebe uma linha, coluna, peca e tabuleiro. Devolve um novo estado"
  (cond
   ( (AND (casa-vaziap line col (tabuleiro table)) (find-piece piece (reserva table)) )
     (list (substituir line col piece (tabuleiro table)) (remover-peca piece (reserva table)) ))
     (t nil)))

(defun human-move (move state)
  "Funcao adicional que trata de realizar a jogada do humano"
  (operador  (convert-to-internal-col (car move)) (- (cadr move) 1) (caddr move) state) )

(defun run-operator (state piece &optional (line 0) (col 0) (depth 0) )
  "Funcao que opera sobre o tabuleiro e tenta jogar a peca no em todas as posicoes do tabuleiro "
  (cond 
   ((and (< col 4) (operador line col piece state) )
    (append
     (list (cria-no (operador line col piece state) (+ 1 depth) state) )
          (run-operator state piece line (+ col 1) depth)))
   ((< col 4) (run-operator state piece line (+ col 1) depth))
   ((and (< line 3)) (run-operator state piece (+ line 1) 0 depth))
   (t nil) ))

;; ==========INTERNAL AUXILIARY FUNCTIONS==========
(defun convert-to-internal-col (col)
  "Converts the human sintax for internal use"
  (- (char-int (char (symbol-name col) 0) ) 65))

(defun validate-sintax (move)
 "Validates the human move sintax"
   (cond
    ( (AND (symbolp (car move)) (numberp (cadr move)) )
      t)
    (t (format t"result:~a" (caddr move) ) nil )) )

(defun find-piece (piece reserved-pieces)
  "Verifies weather the piece exists in the reserve"
  (cond
   ((null reserved-pieces) NIL)
   ((equal piece (car reserved-pieces)) T)
   (T (find-piece piece (cdr reserved-pieces)))))


(defun find-value (list)
  "Verifies weather the piece exists in the reserve"
  (cond
   (
    (AND
     (not(equal 0 (car list)))
     (not(equal 0 (cadr list)))
     (not(equal 0 (caddr list)))
     (not(equal 0 (cadddr list))))
    0
  )
   (t (apply '+
      (list (list-value list 'branca)
                       (list-value list 'preta)
                       (list-value list 'quadrada)
                       (list-value list 'redonda)
                       (list-value list 'baixa)
                       (list-value list 'alta)
                       (list-value list 'oca)
                       (list-value list 'cheia))
       )
      )))

(defun list-value (list cond)
  (cond 
   ( (null list) 0)
   ( (not(atom (car list))) (list-value (append (car list) (cdr list)) cond) )
   ( (eql cond (car list)) (+ 1 (list-value (cdr list) cond)) )
   (t (list-value (cdr list) cond)) ))

;; ==========Problem Domain Specific Alfa Beta Functions==========
;(declaim (ftype function terminal-node-p heuristic-value children))
;; node = <depth> <current-board> <parent-board>

(defun terminal-node-p (node)
  "Verifies weather the node is a leaf node"
  (cond
   ( (verifica-propriedades (tabuleiro (no-estado node))) t)
   (t nil)))

(defun heuristic-value (node)
  "Returns the heuristic value for the node"
  (cond
   ( (<= (nivel-no node) 0)
     (apply '+ (list
                (find-value (linha 0 (tabuleiro (no-estado node))))
                (find-value (linha 1 (tabuleiro (no-estado node))))
                (find-value (linha 2 (tabuleiro (no-estado node))))
                (find-value (linha 3 (tabuleiro (no-estado node))))
                )))
   (t (heuristic-value-child node))))

(defun heuristic-value-child (node)
  "Returns the heuristic value for the node"
  (apply '+ (list
             (find-value (linha 0 (no-estado node)))
             (find-value (linha 1 (no-estado node)))
             (find-value (linha 2 (no-estado node)))
             (find-value (linha 3 (no-estado node)))
         )))
  ;(+ (car node) (+ (line-val (linha (cadr node))) (+col-val (coluna (cadr node)) (+diagonals-val (cadr node)) ))))

(defun children (node)
  "returns all possible children of the current node"
  ;; =========="Poor quality" Code AKA Special vars==========
  (setq node-list (make-hash-table))
  (gen-children node (reserva (no-estado node)))
  (hash-table-vals node-list)
)

(defun gen-children (node pieces)
  (cond
   ( (<= (length pieces) 0) nil )
   (t
    (gen-piece-locations node (car pieces) )
    (gen-children node (cdr pieces))
    )))

(defun hash-table-vals (hash-table)
    (let ((vals ()))
      (maphash (lambda (k v) (push k vals)) hash-table)
      vals))

(defun gen-piece-locations (node piece &optional (line 0) (col 0) )
  "Funcao que gera a lista de filhos de um n�"
  (cond 
   ( (and (< col 4) (operador line col piece node))
    (setf (gethash (tabuleiro (operador line col piece node)) node-list) 
          (list (+ (nivel-no node) 1)  (no-estado node) ))
    ;(setf (gethash count node-list) (list line col))
    (gen-piece-locations node piece line (+ col 1)) )
   ( (< col 4) (gen-piece-locations node piece line (+ col 1) ) )
   ( (and (< line 3)) (gen-piece-locations node piece (+ line 1) 0 ) )
   (t nil) ))

;;; =============================================Metodos Seletores=========================================
(defun cria-no (novo-no &optional (depth 0) (pai nil))
  "cria um novo no"
  (list depth novo-no pai))

(defun no-estado (no)
  "no-estado devolve o estado de um no"
  (cadr no))

(defun no-pai (no)
  "no-estado devolve o estado do pai de um no"
  (caddr no))

(defun nivel-no (no)
  "Funcao devolve o n�vel de um no"
  (car no))

(defun no-existep (no lista algoritmo)
  "Funcao que verifica se o no existe numa lista"
  (cond
   ((null lista) NIL)
   ((equal (no-estado (car lista)) (no-estado no)) T)
   (T (no-existep no (cdr lista) algoritmo))))