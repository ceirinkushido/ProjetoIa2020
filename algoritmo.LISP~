(defvar b-beta -999999)
(defvar b-alfa 999999)

(defun min-ab (a b)
    (cond
     ((eql a 999999) b)
     ((eql b 999999) a)
     ((eql a -999999) -999999)
     ((eql b -999999) -999999)
     (t (min a b))))

(defun max-ab (a b)
  (cond
   ((eql a -999999) b)
   ((eql b -999999) a)
   ((eql a 999999) 999999)
   ((eql b 999999) 999999)
   (t (max a b))))

;;; ===============================================Algoritmos===============================================
;;; MinMax with Alfa-Beta Prunning algorithm
(defun alphabeta (node depth a b maximizing-player-p)
  (when (or (= depth 0) (terminal-node-p node))
    ;(return-from alphabeta node))
    (return-from alphabeta (heuristic-value node)))
  (if maximizing-player-p
      (let ((value b))
        (dolist (child (children node))
          ;(format t "~%beta val:~a" value)
          (setf value (max-ab value (alphabeta child (1- depth) a b nil)))
          (setf a (max-ab a value))
          (when (<= b a)
           ;; beta cut
            (return)))
        value)
    (let ((value a))
      ;(format t "~%alfa val:~a" value)
      (dolist (child (children node))
        (print depth)
        (setf value (min-ab value (alphabeta child (1- depth) a b t)))
        (setf a (min-ab a value))
        (when (<= b a)
          ;; alfa cut
          (return)))
      value)))
